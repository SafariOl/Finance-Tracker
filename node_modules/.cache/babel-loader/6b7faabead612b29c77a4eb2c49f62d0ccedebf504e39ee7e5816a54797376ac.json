{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveProviders = exports.Config = void 0;\nconst axios_1 = __importDefault(require(\"axios\"));\nconst providers_1 = require(\"./providers\");\nconst utils_1 = require(\"./utils\");\n/**\n * Config object that initializes with configuration data\n * passed in by the user.\n *\n * @export\n * @class Config\n */\nclass Config {\n  /**\n   * Creates an instance of Config.\n   * @param {(...ProviderReference[] | undefined[] | string[])} config\n   * @memberof Config\n   */\n  constructor(...config) {\n    /**\n     * Active client.\n     */\n    this._client = axios_1.default.create();\n    /**\n     * Client setter.\n     * @param client  The client.\n     */\n    this.setClient = client => {\n      this._client = client;\n    };\n    /**\n     * Client getter.\n     */\n    this.getClient = () => {\n      return this._client;\n    };\n    /**\n     * Adds a single new, user-defined provider to the list of providers.\n     *\n     * @param {string} name - the new provider name\n     * @param {Provider} provider - the new provider object\n     * @param {boolean} [setActive=false] - should the new provider(s) be prioritized\n     * @memberof Config\n     */\n    this.add = (name, provider, setActive = false) => {\n      this.addMultiple([{\n        name,\n        provider\n      }], setActive);\n    };\n    /**\n     * Adds multiple new, user-defined provider to the list of providers.\n     *\n     * @param {UserDefinedProvider[]} providers - providers to be added\n     * @param {boolean} [setActive=false] - should the new provider(s) be prioritized\n     * @memberof Config\n     */\n    this.addMultiple = (newProviders, setActive = false) => {\n      // Duplicate check\n      newProviders.forEach(p => {\n        if (!(0, utils_1.checkIfUserDefinedProvider)(p)) {\n          throw \"Invalid provider format!\";\n        }\n        if (providers_1.providers[p.name]) {\n          throw \"A provider by this name is already registered!\";\n        }\n        providers_1.providers[p.name] = p.provider;\n      });\n      // Adding provider to active providers\n      this.addProviders(newProviders.map(p => p.provider), setActive);\n    };\n    /**\n     * Removes a specific provider\n     * @param {Provider} provider - provider to be removed\n     * @memberof Config\n     */\n    this.remove = provider => {\n      this._active = this._active.filter(p => p != provider);\n    };\n    this._active = resolveProviders(...config);\n    // adding default fallback\n    this.addProviders([providers_1.providers.ExchangeRateAPI], false);\n  }\n  /**\n   * Provider getter.\n   *\n   * @returns {Provider[]}\n   * @memberof Config\n   */\n  get providers() {\n    return this._active;\n  }\n  /**\n   * Provider setter (adder).\n   *\n   * @param {Provider[]} providers - providers to be added\n   * @param {boolean} [setActive=false] - should the new provider(s) be prioritized\n   * @returns {void}\n   * @memberof Config\n   */\n  addProviders(providers, setActive) {\n    providers = providers.filter(p => {\n      return !this._active.find(a => a == p);\n    });\n    if (setActive) {\n      this._active.unshift(...providers);\n      return;\n    }\n    this._active.push(...providers);\n    return;\n  }\n  /**\n   * Returns the current provider\n   *\n   * @returns {Provider} - current provider\n   * @memberof Config\n   */\n  activeProvider() {\n    return this._active[0];\n  }\n}\nexports.Config = Config;\n/**\n * Config resolver that normalizes configuration input into the config interface\n *\n * @export\n * @param {(...ProviderReference[] | undefined[] | string[])} configuration\n * @returns {Provider[]}\n */\nfunction resolveProviders(...configuration) {\n  // resolve default if none provided.\n  if (typeof configuration === \"undefined\" || !configuration.length) {\n    return [providers_1.providers.ExchangeRateAPI];\n  }\n  // checking for incorrect config types\n  if (typeof configuration[0] !== \"object\" && typeof configuration[0] !== \"undefined\" && typeof configuration[0] !== \"string\") {\n    throw \"You must either supply nothing or a config object (see the 'config' section to see the different APIs that can be used)\";\n  }\n  // returning single provider\n  if (typeof configuration[0] === \"string\") {\n    // constructing in initializationConfig object from string values\n    return [(0, providers_1.resolveProvider)({\n      name: configuration[0],\n      key: configuration[1]\n    })];\n  }\n  // configuration is an array of providers\n  // casting\n  const initializationConfig = configuration;\n  // resolving all providers\n  return initializationConfig.map(provider => (0, providers_1.resolveProvider)(provider));\n}\nexports.resolveProviders = resolveProviders;","map":{"version":3,"names":["axios_1","__importDefault","require","providers_1","utils_1","Config","constructor","config","_client","default","create","setClient","client","getClient","add","name","provider","setActive","addMultiple","newProviders","forEach","p","checkIfUserDefinedProvider","providers","addProviders","map","remove","_active","filter","resolveProviders","ExchangeRateAPI","find","a","unshift","push","activeProvider","exports","configuration","length","resolveProvider","key","initializationConfig"],"sources":["C:\\Users\\yurii\\OneDrive\\Pulpit\\site-anim\\node_modules\\easy-currencies\\src\\parts\\config.ts"],"sourcesContent":["import axios, { AxiosInstance } from \"axios\";\nimport {\n  Provider,\n  providers,\n  resolveProvider,\n  UserDefinedProvider,\n  ProviderReference\n} from \"./providers\";\n\nimport { checkIfUserDefinedProvider } from \"./utils\";\n\n/**\n * Proxy configuration object.\n */\nexport interface ProxyConfiguration {\n  host: string;\n  port: number;\n  auth: { username: string; password: string };\n}\n\n/**\n * Config object that initializes with configuration data\n * passed in by the user.\n *\n * @export\n * @class Config\n */\nexport class Config {\n  /**\n   * Array of active curency API providers.\n   *\n   * @type {Provider[]}\n   * @memberof Config\n   */\n  private _active: Provider[];\n\n  /**\n   * Provider getter.\n   *\n   * @returns {Provider[]}\n   * @memberof Config\n   */\n  get providers(): Provider[] {\n    return this._active;\n  }\n\n  /**\n   * Active client.\n   */\n  private _client: AxiosInstance = axios.create();\n\n  /**\n   * Client setter.\n   * @param client  The client.\n   */\n  setClient = (client: AxiosInstance): void => {\n    this._client = client;\n  };\n\n  /**\n   * Client getter.\n   */\n  getClient = () => {\n    return this._client;\n  };\n\n  /**\n   * Provider setter (adder).\n   *\n   * @param {Provider[]} providers - providers to be added\n   * @param {boolean} [setActive=false] - should the new provider(s) be prioritized\n   * @returns {void}\n   * @memberof Config\n   */\n  private addProviders(providers: Provider[], setActive: boolean): void {\n    providers = providers.filter((p) => {\n      return !this._active.find((a) => a == p);\n    });\n\n    if (setActive) {\n      this._active.unshift(...providers);\n      return;\n    }\n    this._active.push(...providers);\n    return;\n  }\n\n  /**\n   * Adds a single new, user-defined provider to the list of providers.\n   *\n   * @param {string} name - the new provider name\n   * @param {Provider} provider - the new provider object\n   * @param {boolean} [setActive=false] - should the new provider(s) be prioritized\n   * @memberof Config\n   */\n  add = (\n    name: string,\n    provider: Provider,\n    setActive: boolean = false\n  ): void => {\n    this.addMultiple([{ name, provider }], setActive);\n  };\n\n  /**\n   * Adds multiple new, user-defined provider to the list of providers.\n   *\n   * @param {UserDefinedProvider[]} providers - providers to be added\n   * @param {boolean} [setActive=false] - should the new provider(s) be prioritized\n   * @memberof Config\n   */\n  addMultiple = (\n    newProviders: UserDefinedProvider[],\n    setActive: boolean = false\n  ): void => {\n    // Duplicate check\n    newProviders.forEach((p) => {\n      if (!checkIfUserDefinedProvider(p)) {\n        throw \"Invalid provider format!\";\n      }\n\n      if (providers[p.name]) {\n        throw \"A provider by this name is already registered!\";\n      }\n      providers[p.name] = p.provider;\n    });\n\n    // Adding provider to active providers\n    this.addProviders(\n      newProviders.map((p) => p.provider),\n      setActive\n    );\n  };\n\n  /**\n   * Removes a specific provider\n   * @param {Provider} provider - provider to be removed\n   * @memberof Config\n   */\n  remove = (provider: Provider): void => {\n    this._active = this._active.filter((p) => p != provider);\n  };\n\n  /**\n   * Returns the current provider\n   *\n   * @returns {Provider} - current provider\n   * @memberof Config\n   */\n  activeProvider(): Provider {\n    return this._active[0];\n  }\n\n  /**\n   * Creates an instance of Config.\n   * @param {(...ProviderReference[] | undefined[] | string[])} config\n   * @memberof Config\n   */\n  constructor(...config: ProviderReference[] | undefined[] | string[]) {\n    this._active = resolveProviders(...config);\n\n    // adding default fallback\n    this.addProviders([providers.ExchangeRateAPI], false);\n  }\n}\n\n/**\n * Config resolver that normalizes configuration input into the config interface\n *\n * @export\n * @param {(...ProviderReference[] | undefined[] | string[])} configuration\n * @returns {Provider[]}\n */\nexport function resolveProviders(\n  ...configuration: ProviderReference[] | undefined[] | string[]\n): Provider[] {\n  // resolve default if none provided.\n  if (typeof configuration === \"undefined\" || !configuration.length) {\n    return [providers.ExchangeRateAPI];\n  }\n\n  // checking for incorrect config types\n  if (\n    typeof configuration[0] !== \"object\" &&\n    typeof configuration[0] !== \"undefined\" &&\n    typeof configuration[0] !== \"string\"\n  ) {\n    throw \"You must either supply nothing or a config object (see the 'config' section to see the different APIs that can be used)\";\n  }\n\n  // returning single provider\n  if (typeof configuration[0] === \"string\") {\n    // constructing in initializationConfig object from string values\n    return [resolveProvider({ name: configuration[0], key: configuration[1] })];\n  }\n\n  // configuration is an array of providers\n  // casting\n  const initializationConfig = <ProviderReference[]>configuration;\n\n  // resolving all providers\n  return initializationConfig.map((provider) => resolveProvider(provider));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}